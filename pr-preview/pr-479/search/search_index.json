{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Alluka","text":"<p>A type based dependency injection framework for Python 3.11.</p>"},{"location":"#usage","title":"Usage","text":"<p>For how to get started with this library, see the documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install Alluka from PyPI using the following command in any Python 3.11 or above environment.</p> <pre><code>python -m pip install -U alluka\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Before contributing you should read through the contributing guidelines and the code of conduct.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#040-2024-11-24","title":"0.4.0 - 2024-11-24","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for local scoped injection contexts.</li> <li>Provisional support for Python 3.14.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Support for Python 3.9 and 3.10.</li> </ul>"},{"location":"changelog/#033-2024-10-13","title":"0.3.3 - 2024-10-13","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Correctly mark <code>ctx</code> and <code>callback</code> as positional only in the call_with methods   and functions to avoid conflicting with passed-through keyword arguments.</li> </ul>"},{"location":"changelog/#032-2024-10-07","title":"0.3.2 - 2024-10-07","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Support Python 3.13.</li> </ul>"},{"location":"changelog/#031-2024-06-24","title":"0.3.1 - 2024-06-24","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>alluka.abc.Client.auto_inject_async now returns a real asynchronous function   to improve compatibility with some third party libraries which use   <code>asyncio.iscoroutinefunction</code> or inspect.iscoroutinefunction to validate   callbacks.</li> </ul>"},{"location":"changelog/#030-2024-05-09","title":"0.3.0 - 2024-05-09","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>alluka.local is now directly exported on alluka.</li> <li>alluka.Context implementation of alluka.abc.Context which is a basic   DI context implementation with no callback dependency result caching.</li> <li>alluka.CachingContext which extends alluka.Context to add callback   dependency result caching.</li> <li>alluka.OverridingContext shallow DI context implementation for adding   context specific type dependencies to an existing context.</li> <li>alluka.Client.set_make_context method for setting the callback used by   the client to make DI contexts.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Callback dependency results are no-longer cached by default. To return this   behaviour set alluka.CachingContext as the context maker.</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li><code>alluka.BasicContext</code> has been replaced by alluka.CachingContext.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Injected callback results are now properly cached when alluka.CachingContext   is set as the context.</li> </ul>"},{"location":"changelog/#020-2024-04-29","title":"0.2.0 - 2024-04-29","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Transparent auto injection methods on <code>Client</code> at <code>Client.auto_inject</code> and   <code>Client.auto_inject_async</code>. These wrap functions to make calls to them   automatically inject dependencies and are transparent replacements for the   self injecting system.   More information on these can be found   here.</li> <li>A system for setting the injection client for a local scope (as defined by   contextvars) and making dependency injection calls based on said context.   More information on this can be found   here.</li> <li>alluka.abc.Client.make_context method for creating a client bound context.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li><code>get_type_dependency</code> and <code>get_cached_value</code> both now raise a KeyError when   no value is found and no default was provided.</li> <li>alluka.abc.Client.call_with_di and alluka.abc.Client.call_with_async_di   now provide default implementations which use   Client.make_context.</li> <li>alluka.abc.Context.call_with_di and alluka.abc.Context.call_with_async_di   now provide default implementations which use   Context.injection_client.</li> </ul>"},{"location":"changelog/#deprecated_1","title":"Deprecated","text":"<ul> <li><code>Client.as_self_injecting</code> in favour of <code>Client.auto_inject</code>.</li> <li><code>Client.as_async_self_injecting</code> in favour of <code>Client.auto_inject_async</code>.</li> <li><code>alluka.SelfInjecting</code> in favour of <code>Client.auto_inject</code>.</li> <li><code>alluka.AsyncSelfInjecting</code> in favour of <code>Client.auto_inject_async</code>.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li><code>alluka.abc.UNDEFINED</code> and <code>alluka.abc.Undefined</code>.</li> </ul>"},{"location":"changelog/#015-2024-04-22","title":"0.1.5 - 2024-04-22","text":"<ul> <li>Improve error message when attempting to use alluka.inject without DI.</li> </ul>"},{"location":"changelog/#014-2023-12-27","title":"0.1.4 - 2023-12-27","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Python 3.12 support.</li> </ul>"},{"location":"changelog/#013-2022-11-12","title":"0.1.3 - 2022-11-12","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li><code>alluka.abc.Client</code> is now set as a type dependency by default.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Renamed <code>AsyncOnlyError</code> to <code>SyncOnlyError</code> (<code>AsyncOnlyError</code> has been kept as a   deprecated alias).</li> <li>Relaxed typing around DI for async callbacks to allow for returning a union of   <code>Coroutine[Any, Any, T] | T</code>.</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Don't error on async callbacks which return a coroutine after being awaited   during DI when assertions are enabled.</li> </ul>"},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>The project metadata dunder attributes from alluka.   importlib.metadata should be used to get this metadata instead.</li> </ul>"},{"location":"changelog/#012-2022-07-06","title":"0.1.2 - 2022-07-06","text":""},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>The optional <code>introspect_annotations</code> parameter for <code>alluka.Client.__init__</code>   is now keyword only.</li> <li><code>tanjun.abc.Client</code> is now a real <code>abc.ABC</code>.</li> </ul>"},{"location":"changelog/#deprecated_2","title":"Deprecated","text":"<ul> <li><code>alluka.abc.Undefined</code> and <code>alluka.abc.UNDEFINED</code> for removal in <code>v0.2.0</code> as    these will no-longer be used.</li> <li><code>get_type_dependency</code> and <code>get_cached_result</code> returning <code>UNDEFINED</code> as the   default when no default is passed will be replaced by a <code>KeyError</code> raise in   <code>v0.2.0</code>.</li> </ul>"},{"location":"changelog/#011-2022-03-20","title":"0.1.1 - 2022-03-20","text":""},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Regression around handling of \"signature-less\" builtin functions.   A ValueError will no longer be raised in these cases.</li> </ul>"},{"location":"changelog/#010-2022-02-25","title":"0.1.0 - 2022-02-25","text":"<p>All of the <code>0.1.0</code> entries are relative to the feature set exposed while this was a part of Tanjun.</p>"},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Support for synchronous dependency injection (this comes with <code>SyncOnlyError</code>)</li> <li>Abstract interface for the client with limited functionality.</li> <li><code>call_with_di</code> and <code>call_with_async_di</code> to <code>alluka.abc.Context</code> as a shorthand for   executing a callback with that context.</li> <li><code>call_with_di</code>, <code>call_with_async_di</code>, <code>call_with_ctx</code> and <code>call_with_ctx_async</code>   methods to the injection client for executing callbacks with DI.</li> <li>Support for inferring the type of a parameter from its type hint   when no <code>type</code> or <code>callback</code> is explicitly provided.</li> <li>Support for using <code>typing.Annotated</code> to declare parameter DI. This takes two forms:<ul> <li><code>parameter: alluka.Inject[Type]</code> to infer specifically a type dependency.</li> <li><code>parameter: typing.Annotated(Type, alluka.inject(type=.../callback=...))</code>.</li> </ul> </li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Passed keyword arguments are now prioritised over dependency injection.</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":"<ul> <li>The public <code>CallackDescriptor</code> and <code>TypeDescriptor</code> classes as callbacks   are now processed within the client and any necessary caching is kept internal.</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#function-injection","title":"Function injection","text":"<p>This form of dependency injection works by injecting values for keyword arguments during callback execution based on the linked client. This is the current form of dependency injection implemented by Alluka.</p>"},{"location":"usage/#declaring-a-functions-injected-dependencies","title":"Declaring a function's injected dependencies","text":"<p>There are two styles for declaring a function's injected dependencies in Alluka:</p>"},{"location":"usage/#default-descriptors","title":"Default descriptors","text":"<pre><code>def callback(\n    foo: Foo = alluka.inject(type=Foo),\n    bar: BarResult = alluka.inject(callback=bar_callback),\n) -&gt; None:\n    ...\n</code></pre> <p>Assigning the result of alluka.inject to a parameter's default will declare it as requiring an injected type or callback.</p> <pre><code>async def callback(foo: Foo = alluka.inject()) -&gt; None: ...\n</code></pre> <p>If neither <code>type</code> nor <code>callback</code> is passed to alluka.inject then a type dependency will be inferred from the parameter's annotation.</p> <p>Warning</p> <p>The type-hint will need to resolvable/accessible at runtime in the callback's module for it to be inferred (so it can't be hidden behind a typing.TYPE_CHECKING only import or using a type or operation that isn't implemented in the current python version).</p>"},{"location":"usage/#type-hint-metadata","title":"Type-hint metadata","text":"<p>typing.Annotated style type-hint descriptors may be used to declare the injected dependencies for a function.</p> <pre><code>def callback(\n    foo: typing.Annotated[Foo, alluka.inject(type=Foo)],\n    bar: typing.Annotated[BarResult, alluka.inject(callback=bar_callback)],\n) -&gt; None: ...\n</code></pre> <p>Where passing the default descriptors returned by alluka.inject to typing.Annotated lets you declare the type or callback dependency for an argument without effecting non-DI calls to the function (by leaving these parameters required).</p> <pre><code>async def callback(foo: alluka.Injected[Foo]) -&gt; None: ...\n</code></pre> <p>And alluka.Injected provides a shorthand for using typing.Annotated to declare a type dependency.</p> <p>Note</p> <p>alluka.Injected can be safely passed to typing.Annotated as the first type argument or vice versa thanks to how Annotated handles nesting.</p>"},{"location":"usage/#calling-functions-with-dependency-injection","title":"Calling functions with dependency injection","text":"<pre><code>client = alluka.Client()\n\nasync def callback(\n    argument: int,\n    /,\n    injected: alluka.Injected[Foo],\n    keyword_arg: str,\n) -&gt; int:\n    ...\n\n...\n\nresult = await client.call_with_async_di(callback, 123, keyword_arg=\"ok\")\n</code></pre> <p>Client.call_with_async_di can be used to execute a function with async dependency injection. Any positional or keyword arguments which are passed with the function will be passed through to the function with the injected values.</p> <p>Note</p> <p>While both sync and async functions may be executed with <code>call_with_async_di</code>, you'll always have to await <code>call_with_async_di</code> to get the result of the call.</p> <pre><code>client = alluka.Client()\n\ndef callback(\n    argument: int,\n    /,\n    injected: alluka.Injected[Foo],\n    keyword_arg: str,\n) -&gt; int:\n    ...\n\n...\n\nresult = client.call_with_di(callback, 123, keyword_arg=\"ok\")\n</code></pre> <p>Client.call_with_di can be used to execute a function with purely sync dependency injection. This has similar semantics to <code>call_with_async_di</code> for passed through arguments but comes with the limitation that only sync functions may be used and any async callback dependencies will lead to alluka.SyncOnlyError being raised.</p> <pre><code>def foo(ctx: alluka.Injected[alluka.abc.Context]) -&gt; None:\n    result = ctx.call_with_di(other_callback, 542, keyword_arg=\"meow\")\n</code></pre> <p>Alternatively, Context.call_with_di and Context.call_with_async_di can be used to execute functions with dependency injection while preserving the current injection context.</p> <pre><code>async def bar(ctx: alluka.Injected[alluka.abc.Context]) -&gt; None:\n    result = await ctx.call_with_async_di(other_callback, 123, keyword_arg=\"ok\")\n</code></pre>"},{"location":"usage/#automatic-dependency-injection","title":"Automatic dependency injection","text":"<pre><code>client = alluka.Client()\n\n@client.auto_inject\ndef callback(other_arg: str, value: TypeA = alluka.inject()) -&gt; None: ...\n\ncallback(other_arg=\"beep\")  # `value` will be injected.\n</code></pre> <p>Client.auto_inject and Client.auto_inject_async can be used to tie a callback to a specific dependency injection client to enable implicit dependency injection without the need to call <code>call_with_(async_)_di</code> every time the callback is called.</p> <pre><code>client = alluka.Client()\n\n@client.auto_inject_async\nasync def callback(value: TypeA = alluka.inject()) -&gt; None: ...\n\nawait callback()  # `value` will be injected.\n</code></pre> <p>Client.auto_inject comes with similar limitations to Client.call_with_di in that the auto-injecting callback it creates will fail if any of the callback dependencies are asynchronous.</p>"},{"location":"usage/#using-the-client","title":"Using the client","text":""},{"location":"usage/#adding-type-dependencies","title":"Adding type dependencies","text":"<pre><code>client = (\n    alluka.Client()\n    .set_type_dependency(TypeA, type_a_impl)\n    .set_type_dependency(TypeB, type_b_impl)\n)\n</code></pre> <p>For a type dependency to work, the linked client has to have an implementation loaded for each type. Client.set_type_dependency is used to pair up the types you'll be using in alluka.inject with initialised implementations of them.</p>"},{"location":"usage/#overriding-callback-dependencies","title":"Overriding callback dependencies","text":"<pre><code>client = alluka.Client().set_callback_override(default_callback, other_callback)\n</code></pre> <p>While callback dependencies can work on their own without being explicitly declared on the client (unless they're relying on a type dependency themselves), they can still be overridden on a client level using Client.set_callback_override.</p> <p>Injected callbacks should only be overridden with a callback which returns a compatible type but their signatures do not need to match and async callbacks can be overridden with sync with vice versa also working (although overriding a sync callback with an async callback will prevent the callback from being used in a sync context).</p>"},{"location":"usage/#local-client","title":"Local client","text":"<p>Alluka provides a system in alluka.local which lets you associate an Alluka client or context with the local scope. This can make dependency injection easier for application code as it avoids the need to lug around an injection client or context.</p> <p>The local \"scope\" will either be the current thread, an async event loop (e.g. asyncio event loop), an async task, or an async future.</p> <p>While child async tasks and futures will inherit the local client/context, child threads will not.</p> <pre><code>async def callback() -&gt; None:\n    result = await alluka.local.call_with_async_di(async_callback)\n\nwith alluka.local.scope_client() as client:\n    client.set_type_dependency(TypeA, type_a_impl)\n\n    await callback()\n</code></pre> <p>Either alluka.local.initialize or alluka.local.scope_client needs to be called to declare a client within the current scope before the other functionality in alluka.local can be used. These can be passed a client to declare but defaults to creating a new client.</p> <p>The client is then configured like normal and alluka.local.get_client can be used to get the set client for the current scope.</p> <pre><code>client = alluka.Client()\n\ncontext = alluka.OverridingContext.from_client(client).set_type_dependency(TypeA, TypeA())\n\nwith alluka.local.scope_context(context):\n    alluka.local.call_with_di(bar_callback)\n</code></pre> <p>scope_context can be used to set the Injection context for a scope and will also set the context's client as the local client. This will be prioritised over alluka.local.scope_client and <code>initialize</code> when making calls to the local call with DI functions. alluka.local.get_context returns the set context.</p> <p>scope_client/scope_context are recommended over <code>initialize</code> as these avoid declaring the client/context globally.</p> <pre><code>client = alluka.local.initialize()\nclient.set_type_dependency(TypeA, type_a_impl)\n\n...\n\nasync def callback(value: TypeA = alluka.inject()) -&gt; None: ...\n\nresult = await alluka.local.call_with_async_di(callback)\n</code></pre> <p>alluka.local.call_with_async_di, alluka.local.call_with_di can be used to call a function with the dependency injection client that's set for the current scope.</p> <pre><code>@alluka.local.auto_inject_async\nasync def callback(value: TypeA = alluka.inject()) -&gt; None: ...\n\nwith alluka.local.scope_client() as client:\n    client.set_type_dependency(TypeA, type_a_impl)\n\n    await callback()\n</code></pre> <p>alluka.local.auto_inject, and alluka.local.auto_inject_async act a little different to the similar client methods: instead of binding a callback to a specific client to enable automatic dependency injection, these will get the local client/context for dependency injection when the auto-injecting callback is called.</p> <p>As such <code>auto_inject</code> and <code>auto_inject_async</code> can be used to make an auto-injecting callback before a local client/context has been set but any calls to the returned auto-injecting callbacks will only work within a scope where <code>initialise</code> or <code>scope_client</code> or <code>scope_context</code> is in effect.</p>"},{"location":"usage/#custom-injection-contexts","title":"Custom injection contexts","text":"<p>Under the hood Alluka builds a alluka.abc.Context for each call to a <code>call_with_{async}_di</code> method.</p> <pre><code>client = alluka.Client().set_make_context(alluka.CachingContext)\n</code></pre> <p>alluka.Client.set_make_context can be used to change how the client creates DI contexts to customise how dependency injection behaves.</p>"},{"location":"usage/#caching-injected-callback-results","title":"Caching injected callback results","text":"<p>By default, injected callbacks are called every time they're found within the context of a dependency injection call.</p> <p>alluka.CachingContext can be set as the component maker to enable the caching of the result of callback dependencies.</p> <pre><code>client = alluka.Client().set_make_context(alluka.CachingContext)\nstate = 0\n\ndef injected_callback() -&gt; int:\n    nonlocal state\n    state += 1\n\n    return state\n\ndef callback(\n    result: int = alluka.inject(callback=injected_callback),\n    other_result: int = alluka.inject(callback=injected_callback),\n) -&gt; None:\n    print(result)\n    print(other_result)\n\nclient.call_with_di(callback)\nprint(\"-\")\nclient.call_with_di(callback)\n</code></pre> <p>This example will result in the following output where <code>state</code> is only injected once per top-level call with <code>call_with_di</code>.</p> <pre><code>&gt;&gt;&gt; 1\n&gt;&gt;&gt; -\n&gt;&gt;&gt; 1\n</code></pre> <p>This caches the results in a DI context so if the same DI context is used to call multiple callbacks with dependency injection then these cached values will be persisted between those calls.</p>"},{"location":"usage/#context-specific-type-dependencies","title":"Context-specific type dependencies","text":"<pre><code>def callback(ctx: alluka.Injected[alluka.abc.Context]) -&gt; None:\n    ctx = alluka.OverridingContext(ctx).set_type_dependency(TypeA, type_a_impl)\n\n    ctx.call_with_di(other_callback)\n</code></pre> <p>alluka.OverridingContext to add context specific type dependency overrides to an existing DI context.</p> <pre><code>client = alluka.Client().set_type_dependency(TypeA, type_a_impl)\n\nctx = alluka.OverridingContext.from_client(client).set_type_dependency(TypeB, type_b_impl)\n\nctx.call_with_di(other_callback)\n</code></pre> <p>alluka.OverridingContext.from_client lets you create a context with type dependency overrides straight from an Alluka client.</p>"},{"location":"reference/","title":"alluka","text":"<p>A type based dependency injection framework for Python 3.9+.</p>"},{"location":"reference/#alluka.Injected","title":"Injected  <code>module-attribute</code>","text":"<pre><code>Injected = Annotated[_T, TYPE]\n</code></pre> <p>Type alias used to declare a keyword argument as requiring an injected type.</p> <p>If a union (e.g. <code>typing.Union[A, B]</code>, <code>A | B</code>, <code>typing.Optional[A]</code>) is passed then each type in the union will be tried separately rather than the literal type, allowing for resolving <code>A | B</code> to the value set by <code>set_type_dependency(B, ...)</code>.</p> <p>If a union has <code>None</code> as one of its types (including <code>Optional[T]</code>) then <code>None</code> will be passed for the parameter if none of the types could be resolved using the linked client.</p> <p>Note</p> <p>This is a typing.Annotated alias and the behaviour for nested Annotated types may be found at the docs for it typing.Annotated.</p>"},{"location":"reference/#alluka.AllukaError","title":"AllukaError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for the custom errors raised by Alluka.</p>"},{"location":"reference/#alluka.AsyncSelfInjecting","title":"AsyncSelfInjecting","text":"<p>               Bases: <code>AsyncSelfInjecting[_CallbackSigT]</code></p> <p>Deprecated class for marking async functions as self-injecting.</p> <p>deprecated</p> <p>This is deprecated as of <code>v0.2.0</code>, Use Client.auto_inject_async.</p>"},{"location":"reference/#alluka.AsyncSelfInjecting.__init__","title":"__init__","text":"<pre><code>__init__(client, callback)\n</code></pre> <p>Initialise a self injecting callback.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Client</code>)           \u2013            <p>The injection client to use to resolve dependencies.</p> </li> <li> <code>callback</code>               (<code>CallbackSig</code>)           \u2013            <p>The callback to make self-injecting.</p> <p>This may be sync or async.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>callback</code> has any injected arguments which can only be passed positionally.</p> </li> </ul>"},{"location":"reference/#alluka.BasicContext","title":"BasicContext","text":"<p>               Bases: <code>CachingContext</code></p> <p>Deprecated alias of alluka.CachingContext.</p> <p>deprecated</p> <p>This is deprecated as of <code>v0.3.0</code>. use alluka.Context or alluka.CachingContext. alluka.OverridingContext should be used as a replacement for the undocumented type special casing.</p>"},{"location":"reference/#alluka.BasicContext.call_with_async_di","title":"call_with_async_di  <code>async</code>","text":"<pre><code>call_with_async_di(callback, /, *args, **kwargs)\n</code></pre> <p>Asynchronously call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to call.</p> <p>This may be sync or async.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> </ul>"},{"location":"reference/#alluka.BasicContext.call_with_di","title":"call_with_di","text":"<pre><code>call_with_di(callback: collections.Callable[..., _CoroT[typing.Any]], /, *args: typing.Any, **kwargs: typing.Any) -&gt; typing.NoReturn\n</code></pre><pre><code>call_with_di(callback: collections.Callable[..., _T], /, *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>call_with_di(callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[..., _T]</code>)           \u2013            <p>The callback to call.</p> <p>This must be sync.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/#alluka.CachingContext","title":"CachingContext","text":"<p>               Bases: <code>Context</code></p> <p>Basic implementation of alluka.abc.Context with callback result caching.</p>"},{"location":"reference/#alluka.CachingContext.__init__","title":"__init__","text":"<pre><code>__init__(client)\n</code></pre> <p>Initialise a caching injection context.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Client</code>)           \u2013            <p>The injection client this context is bound to.</p> </li> </ul>"},{"location":"reference/#alluka.CachingContext.call_with_async_di","title":"call_with_async_di  <code>async</code>","text":"<pre><code>call_with_async_di(callback, /, *args, **kwargs)\n</code></pre> <p>Asynchronously call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to call.</p> <p>This may be sync or async.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> </ul>"},{"location":"reference/#alluka.CachingContext.call_with_di","title":"call_with_di","text":"<pre><code>call_with_di(callback: collections.Callable[..., _CoroT[typing.Any]], /, *args: typing.Any, **kwargs: typing.Any) -&gt; typing.NoReturn\n</code></pre><pre><code>call_with_di(callback: collections.Callable[..., _T], /, *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>call_with_di(callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[..., _T]</code>)           \u2013            <p>The callback to call.</p> <p>This must be sync.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/#alluka.Client","title":"Client","text":"<p>               Bases: <code>Client</code></p> <p>Standard implementation of a dependency injection client.</p> <p>This is used to track type dependencies and execute callbacks.</p>"},{"location":"reference/#alluka.Client.__init__","title":"__init__","text":"<pre><code>__init__(*, introspect_annotations=True)\n</code></pre> <p>Initialise an injector client.</p>"},{"location":"reference/#alluka.Client.auto_inject","title":"auto_inject","text":"<pre><code>auto_inject(callback)\n</code></pre> <p>Wrap a function to make calls to it always inject dependencies.</p> <p>Examples:</p> <pre><code>@client.auto_inject\ndef callback(dep: Injected[Type]) -&gt; None:\n    ...\n\ncallback()  # The requested dependencies will be passed.\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[_P, _T]</code>)           \u2013            <p>The callback to wrap with DI.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The wrapped auto injecting callback.</p> </li> </ul>"},{"location":"reference/#alluka.Client.auto_inject_async","title":"auto_inject_async","text":"<pre><code>auto_inject_async(callback)\n</code></pre> <p>Wrap an async function to make calls to it always inject dependencies.</p> <p>Examples:</p> <pre><code>@client.auto_inject_async\nasync def callback(dep: Injected[Type]) -&gt; None:\n    ...\n\nawait callback()  # The requested dependencies will be passed.\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[_P, _CoroT[_T]]</code>)           \u2013            <p>The callback to wrap with DI.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The wrapped auto injecting callback.</p> </li> </ul>"},{"location":"reference/#alluka.Client.call_with_async_di","title":"call_with_async_di  <code>async</code>","text":"<pre><code>call_with_async_di(callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with async dependency injection.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to call.</p> <p>This may be sync or async.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/#alluka.Client.call_with_di","title":"call_with_di","text":"<pre><code>call_with_di(callback: collections.Callable[..., _CoroT[typing.Any]], /, *args: typing.Any, **kwargs: typing.Any) -&gt; typing.NoReturn\n</code></pre><pre><code>call_with_di(callback: collections.Callable[..., _T], /, *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>call_with_di(callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with sync dependency injection.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[..., _T]</code>)           \u2013            <p>The callback to call.</p> <p>This must be sync.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/#alluka.Client.set_make_context","title":"set_make_context","text":"<pre><code>set_make_context(make_context)\n</code></pre> <p>Set the callback used to make DI contexts for this client.</p> <p>Parameters:</p> <ul> <li> <code>make_context</code>               (<code>Callable[[Self], Context]</code>)           \u2013            <p>Callback to use to create DI contexts.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The client to enable chained calls.</p> </li> </ul>"},{"location":"reference/#alluka.Context","title":"Context","text":"<p>               Bases: <code>Context</code></p> <p>Basic implementation of alluka.abc.Context without caching.</p>"},{"location":"reference/#alluka.Context.__init__","title":"__init__","text":"<pre><code>__init__(client)\n</code></pre> <p>Initialise an injection context.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Client</code>)           \u2013            <p>The injection client this context is bound to.</p> </li> </ul>"},{"location":"reference/#alluka.Context.cache_result","title":"cache_result","text":"<pre><code>cache_result(callback, value)\n</code></pre> <p>Cache the result of a callback within the scope of this context.</p> <p>Whether this does anything or is a noop is implementation detail.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to cache the result of.</p> </li> <li> <code>value</code>               (<code>_T</code>)           \u2013            <p>The value to cache.</p> </li> </ul>"},{"location":"reference/#alluka.Context.call_with_async_di","title":"call_with_async_di  <code>async</code>","text":"<pre><code>call_with_async_di(callback, /, *args, **kwargs)\n</code></pre> <p>Asynchronously call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to call.</p> <p>This may be sync or async.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> </ul>"},{"location":"reference/#alluka.Context.call_with_di","title":"call_with_di","text":"<pre><code>call_with_di(callback: collections.Callable[..., _CoroT[typing.Any]], /, *args: typing.Any, **kwargs: typing.Any) -&gt; typing.NoReturn\n</code></pre><pre><code>call_with_di(callback: collections.Callable[..., _T], /, *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>call_with_di(callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[..., _T]</code>)           \u2013            <p>The callback to call.</p> <p>This must be sync.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/#alluka.Context.get_cached_result","title":"get_cached_result","text":"<pre><code>get_cached_result(callback: CallbackSig[_T]) -&gt; _T\n</code></pre><pre><code>get_cached_result(callback: CallbackSig[_T], /, *, default: _DefaultT) -&gt; _T | _DefaultT\n</code></pre> <pre><code>get_cached_result(callback, /, *, default=_NO_VALUE)\n</code></pre> <p>Get the cached result of a callback.</p> <p>This will always raise/default for context implementations with no caching.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to get the cached result of.</p> </li> <li> <code>default</code>               (<code>_DefaultT | _NoValue</code>, default:                   <code>_NO_VALUE</code> )           \u2013            <p>The default value to return if the callback is not cached.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T | _DefaultT</code>           \u2013            <p>The cached result of the callback if found.</p> <p>If the callback's result hasn't been cached or caching isn't implementing then this will return the value of <code>default</code> if it is provided.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no value was found when no default was provided.</p> </li> </ul>"},{"location":"reference/#alluka.InjectedDescriptor","title":"InjectedDescriptor","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Descriptor used to a declare keyword-argument as requiring an injected dependency.</p> <p>This is the type returned by alluka.inject.</p>"},{"location":"reference/#alluka.InjectedDescriptor.callback","title":"callback  <code>instance-attribute</code>","text":"<pre><code>callback = callback\n</code></pre> <p>The callback to use to resolve the parameter's value.</p> <p>If this is <code>None</code> then this is a type dependency.</p>"},{"location":"reference/#alluka.InjectedDescriptor.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type to use to resolve the parameter's value.</p> <p>If both this and <code>callback</code> are <code>None</code>, then this is a type dependency and the type will be inferred from the parameter's annotation.</p>"},{"location":"reference/#alluka.InjectedDescriptor.__init__","title":"__init__","text":"<pre><code>__init__(*, callback=None, type=None)\n</code></pre> <p>Initialise an injection default descriptor.</p> <p>Note</p> <p>If neither <code>type</code> or <code>callback</code> is provided, an injected type will be inferred from the argument's annotation.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T] | None</code>, default:                   <code>None</code> )           \u2013            <p>The callback to use to resolve the dependency.</p> <p>If this callback has no type dependencies then this will still work without an injection context but this can be overridden using alluka.abc.Client.set_callback_override.</p> </li> <li> <code>type</code>               (<code>_TypeT[_T] | None</code>, default:                   <code>None</code> )           \u2013            <p>The type of the dependency to resolve.</p> <p>If a union (e.g. <code>typing.Union[A, B]</code>, <code>A | B</code>, <code>typing.Optional[A]</code>) is passed for <code>type</code> then each type in the union will be tried separately after the litarl union type is tried, allowing for resolving <code>A | B</code> to the value set by <code>set_type_dependency(B, ...)</code>.</p> <p>If a union has <code>None</code> as one of its types (including <code>Optional[T]</code>) then <code>None</code> will be passed for the parameter if none of the types could be resolved using the linked client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both <code>callback</code> and <code>type</code> are provided.</p> </li> </ul>"},{"location":"reference/#alluka.MissingDependencyError","title":"MissingDependencyError","text":"<p>               Bases: <code>AllukaError</code></p> <p>Error raised when a dependency couldn't be found.</p>"},{"location":"reference/#alluka.MissingDependencyError.dependency_type","title":"dependency_type  <code>instance-attribute</code>","text":"<pre><code>dependency_type = dependency_type\n</code></pre> <p>Type of the missing dependency.</p>"},{"location":"reference/#alluka.MissingDependencyError.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre> <p>The error's message.</p>"},{"location":"reference/#alluka.MissingDependencyError.__init__","title":"__init__","text":"<pre><code>__init__(message, dependency_type)\n</code></pre> <p>Initialise a missing dependency error.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The error message.</p> </li> </ul>"},{"location":"reference/#alluka.OverridingContext","title":"OverridingContext","text":"<p>               Bases: <code>Context</code></p> <p>Context which exists to override an existing context with special-cased type-dependencies.</p> <p>Examples:</p> <pre><code>def other_callback(value: alluka.Inject[Type]) -&gt; None:\n    ...\n\ndef callback(ctx: alluka.Inject[alluka.abc.Context]) -&gt; None:\n    ctx = alluka.OverridingContext(ctx).set_type_dependency(Type, value)\n\n    ctx.call_with_di(other_callback)\n</code></pre> <pre><code>client = alluka.abc.Client().set_type_dependency(Type, value)\nctx = alluka.OverridingContext.from_client(client).set_type_dependency(OtherType, value)\n</code></pre>"},{"location":"reference/#alluka.OverridingContext.__init__","title":"__init__","text":"<pre><code>__init__(context)\n</code></pre> <p>Initialise an overriding context.</p> <p>While this is designed to wrap an existing context, OverridingContext.from_client can be used to create this from an alluka client.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context</code>)           \u2013            <p>The context to wrap.</p> </li> </ul>"},{"location":"reference/#alluka.OverridingContext.call_with_async_di","title":"call_with_async_di  <code>async</code>","text":"<pre><code>call_with_async_di(callback, /, *args, **kwargs)\n</code></pre> <p>Asynchronously call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to call.</p> <p>This may be sync or async.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> </ul>"},{"location":"reference/#alluka.OverridingContext.call_with_di","title":"call_with_di","text":"<pre><code>call_with_di(callback: collections.Callable[..., _CoroT[typing.Any]], /, *args: typing.Any, **kwargs: typing.Any) -&gt; typing.NoReturn\n</code></pre><pre><code>call_with_di(callback: collections.Callable[..., _T], /, *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>call_with_di(callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[..., _T]</code>)           \u2013            <p>The callback to call.</p> <p>This must be sync.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/#alluka.OverridingContext.from_client","title":"from_client  <code>classmethod</code>","text":"<pre><code>from_client(client)\n</code></pre> <p>Create an overriding context from an injection client.</p> <p>This will wrap the context returned by Client.make_context.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Client</code>)           \u2013            <p>The alluka client to make an overriding context for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OverridingContext</code>           \u2013            <p>The created overriding context.</p> </li> </ul>"},{"location":"reference/#alluka.OverridingContext.set_type_dependency","title":"set_type_dependency","text":"<pre><code>set_type_dependency(type_, value)\n</code></pre> <p>Add a context specific type dependency.</p> <p>Parameters:</p> <ul> <li> <code>type_</code>               (<code>type[_T]</code>)           \u2013            <p>The type of the dependency to add an implementation for.</p> </li> <li> <code>value</code>               (<code>_T</code>)           \u2013            <p>The value of the dependency.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The context to allow chaining.</p> </li> </ul>"},{"location":"reference/#alluka.SelfInjecting","title":"SelfInjecting","text":"<p>               Bases: <code>SelfInjecting[_SyncCallbackT]</code></p> <p>Deprecated class for marking functions as self-injecting.</p> <p>deprecated</p> <p>This is deprecated as of <code>v0.2.0</code>, Use Client.auto_inject.</p>"},{"location":"reference/#alluka.SelfInjecting.__init__","title":"__init__","text":"<pre><code>__init__(client, callback)\n</code></pre> <p>Initialise a sync self injecting callback.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Client</code>)           \u2013            <p>The injection client to use to resolve dependencies.</p> </li> <li> <code>callback</code>               (<code>Callable</code>)           \u2013            <p>The callback to make self-injecting.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>callback</code> has any injected arguments which can only be passed positionally.</p> </li> </ul>"},{"location":"reference/#alluka.SyncOnlyError","title":"SyncOnlyError","text":"<p>               Bases: <code>AllukaError</code></p> <p>Error raised when trying to execute async DI in a sync context.</p>"},{"location":"reference/#alluka.inject","title":"inject","text":"<pre><code>inject(*, callback: alluka.CallbackSig[_T]) -&gt; _T\n</code></pre><pre><code>inject(*, type: _TypeT[_T]) -&gt; _T\n</code></pre><pre><code>inject(*, type: typing.Any = None) -&gt; typing.Any\n</code></pre> <pre><code>inject(*, callback=None, type=None)\n</code></pre> <p>Declare a keyword-argument as requiring an injected dependency.</p> <p>This may be assigned to an argument's default value to declare injection or as a part of its Annotated metadata.</p> <p>Note</p> <p>If neither <code>type</code> nor <code>callback</code> is provided, an injected type will be inferred from the argument's annotation.</p> <p>Examples:</p> <pre><code>async def callback(\n    # Here we require an implementation of the type `Component` to be\n    # injected.\n    injected_type: Component = alluka.inject(type=Component)\n    # Here we inject an out-of-scope callback which itself is taking\n    # advantage of type injectioallukan.\n    callback_result: ResultT = alluka.inject(callback=injected_callback)\n) -&gt; None:\n    raise NotImplementedError\n\n...\n# where client is an `alluka.Client` instance.\nresult = await client.call_with_async_di(callback)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T] | None</code>, default:                   <code>None</code> )           \u2013            <p>The callback to use to resolve the dependency.</p> <p>If this callback has no type dependencies then this will still work without an injection context but this can be overridden using <code>alluka.abc.Client.set_callback_override</code>.</p> </li> <li> <code>type</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The type of the dependency to resolve.</p> <p>If a union (e.g. <code>typing.Union[A, B]</code>, <code>A | B</code>, <code>typing.Optional[A]</code>) is passed for <code>type</code> then each type in the union will be tried separately rather than the literal type, allowing for resolving <code>A | B</code> to the value set by <code>set_type_dependency(B, ...)</code>.</p> <p>If a union has <code>None</code> as one of its types (including <code>Optional[T]</code>) then <code>None</code> will be passed for the parameter if none of the types could be resolved using the linked client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both <code>type</code> and <code>callback</code> are provided.</p> </li> </ul>"},{"location":"reference/abc/","title":"alluka.abc","text":"<p>Alluka's abstract interfaces.</p>"},{"location":"reference/abc/#alluka.abc.CallbackSig","title":"CallbackSig  <code>module-attribute</code>","text":"<pre><code>CallbackSig = Callable[..., _CoroT[_T] | _T]\n</code></pre> <p>Type-hint of a injector callback.</p> <p>Note</p> <p>Dependency dependency injection is recursively supported, meaning that the keyword arguments for a dependency callback may also ask for dependencies themselves.</p> <p>This may either be a sync or asyc function with dependency injection being available for the callback's keyword arguments but dynamically returning either a coroutine or raw value may lead to errors.</p> <p>Dependent on the context positional arguments may also be proivded.</p>"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting","title":"AsyncSelfInjecting","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_CallbackT]</code></p> <p>Deprecated interface of a class for marking async functions as self-injecting.</p> <p>deprecated</p> <p>This is deprecated as of <code>v0.2.0</code>, use Client.auto_inject_async.</p>"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting.callback","title":"callback  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>callback\n</code></pre> <p>The callback this wraps.</p>"},{"location":"reference/abc/#alluka.abc.AsyncSelfInjecting.__call__","title":"__call__  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>__call__(*args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre><pre><code>__call__(*args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Call this with the provided arguments and any injected arguments.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback alongside injected arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The callback's result.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client","title":"Client","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface of a dependency injection client.</p>"},{"location":"reference/abc/#alluka.abc.Client.as_async_self_injecting","title":"as_async_self_injecting  <code>abstractmethod</code>","text":"<pre><code>as_async_self_injecting(callback)\n</code></pre> <p>Deprecated callback for making async functions auto-inject.</p> <p>deprecated</p> <p>This is deprecated as of <code>v0.2.0</code>, use Client.auto_inject_async.</p>"},{"location":"reference/abc/#alluka.abc.Client.as_self_injecting","title":"as_self_injecting  <code>abstractmethod</code>","text":"<pre><code>as_self_injecting(callback)\n</code></pre> <p>Deprecated callback for making functions auto-inject.</p> <p>deprecated</p> <p>This is deprecated as of <code>v0.2.0</code>, use Client.auto_inject.</p>"},{"location":"reference/abc/#alluka.abc.Client.auto_inject","title":"auto_inject","text":"<pre><code>auto_inject(callback)\n</code></pre> <p>Wrap a function to make calls to it always inject dependencies.</p> <p>Examples:</p> <pre><code>@client.auto_inject\ndef callback(dep: Injected[Type]) -&gt; None:\n    ...\n\ncallback()  # The requested dependencies will be passed.\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[_P, _T]</code>)           \u2013            <p>The callback to wrap with DI.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The wrapped auto injecting callback.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.auto_inject_async","title":"auto_inject_async","text":"<pre><code>auto_inject_async(callback)\n</code></pre> <p>Wrap an async function to make calls to it always inject dependencies.</p> <p>Examples:</p> <pre><code>@client.auto_inject_async\nasync def callback(dep: Injected[Type]) -&gt; None:\n    ...\n\nawait callback()  # The requested dependencies will be passed.\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[_P, _CoroT[_T]]</code>)           \u2013            <p>The callback to wrap with DI.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The wrapped auto injecting callback.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.call_with_async_di","title":"call_with_async_di  <code>async</code>","text":"<pre><code>call_with_async_di(callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with async dependency injection.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to call.</p> <p>This may be sync or async.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.call_with_ctx","title":"call_with_ctx  <code>abstractmethod</code>","text":"<pre><code>call_with_ctx(ctx: Context, callback: collections.Callable[..., _CoroT[typing.Any]], /, *args: typing.Any, **kwargs: typing.Any) -&gt; typing.NoReturn\n</code></pre><pre><code>call_with_ctx(ctx: Context, callback: collections.Callable[..., _T], /, *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>call_with_ctx(ctx, callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with an existing DI context.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The DI context to call the callback with.</p> <p>This will be used for scoped type injection.</p> </li> <li> <code>callback</code>               (<code>Callable[..., _T]</code>)           \u2013            <p>The callback to call.</p> <p>This must be sync.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.call_with_ctx_async","title":"call_with_ctx_async  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>call_with_ctx_async(ctx, callback, /, *args, **kwargs)\n</code></pre> <p>Asynchronously call a function with a pre-existing DI context.</p> <p>Parameters:</p> <ul> <li> <code>ctx</code>               (<code>Context</code>)           \u2013            <p>The DI context to call the callback with.</p> <p>This will be used for scoped type injection.</p> </li> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to call.</p> <p>This may be sync or async.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.call_with_di","title":"call_with_di","text":"<pre><code>call_with_di(callback: collections.Callable[..., _CoroT[typing.Any]], /, *args: typing.Any, **kwargs: typing.Any) -&gt; typing.NoReturn\n</code></pre><pre><code>call_with_di(callback: collections.Callable[..., _T], /, *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>call_with_di(callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with sync dependency injection.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[..., _T]</code>)           \u2013            <p>The callback to call.</p> <p>This must be sync.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.get_callback_override","title":"get_callback_override  <code>abstractmethod</code>","text":"<pre><code>get_callback_override(callback)\n</code></pre> <p>Get the override for a specific injected callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The injected callback to get the override for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CallbackSig[_T] | None</code>           \u2013            <p>The override if found, else None.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.get_type_dependency","title":"get_type_dependency  <code>abstractmethod</code>","text":"<pre><code>get_type_dependency(type_: type[_T]) -&gt; _T\n</code></pre><pre><code>get_type_dependency(type_: type[_T], /, *, default: _DefaultT) -&gt; _T | _DefaultT\n</code></pre> <pre><code>get_type_dependency(type_, /, *, default=...)\n</code></pre> <p>Get the implementation for an injected type.</p> <p>Parameters:</p> <ul> <li> <code>type_</code>               (<code>type[_T]</code>)           \u2013            <p>The associated type.</p> </li> <li> <code>default</code>               (<code>_DefaultT</code>, default:                   <code>...</code> )           \u2013            <p>The default value to return if the type is not implemented.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T | _DefaultT</code>           \u2013            <p>The resolved type if found.</p> <p>If the type isn't implemented then the value of <code>default</code> will be returned if it is provided.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no dependency was found when no default was provided.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.make_context","title":"make_context  <code>abstractmethod</code>","text":"<pre><code>make_context()\n</code></pre> <p>Create a dependency injection context.</p> <p>Returns:</p> <ul> <li> <code>Context</code>           \u2013            <p>The created DI context, bound to the current client.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.remove_callback_override","title":"remove_callback_override  <code>abstractmethod</code>","text":"<pre><code>remove_callback_override(callback)\n</code></pre> <p>Remove a callback override.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The injected callback to remove the override for.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The client instance to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no override is found for the callback.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.remove_type_dependency","title":"remove_type_dependency  <code>abstractmethod</code>","text":"<pre><code>remove_type_dependency(type_)\n</code></pre> <p>Remove a type dependency.</p> <p>Parameters:</p> <ul> <li> <code>type_</code>               (<code>type[Any]</code>)           \u2013            <p>The associated type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The client instance to allow chaining.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If <code>type</code> is not registered.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.set_callback_override","title":"set_callback_override  <code>abstractmethod</code>","text":"<pre><code>set_callback_override(callback, override)\n</code></pre> <p>Override a specific injected callback.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The injected callback to override.</p> </li> <li> <code>override</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to use instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The client instance to allow chaining.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Client.set_type_dependency","title":"set_type_dependency  <code>abstractmethod</code>","text":"<pre><code>set_type_dependency(type_, value)\n</code></pre> <p>Set the value for a type dependency.</p> <p>Parameters:</p> <ul> <li> <code>type_</code>               (<code>type[_T]</code>)           \u2013            <p>The type of the dependency to add an implementation for.</p> </li> <li> <code>value</code>               (<code>_T</code>)           \u2013            <p>The value of the dependency.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The client instance to allow chaining.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Context","title":"Context","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract interface of an injection context.</p>"},{"location":"reference/abc/#alluka.abc.Context.injection_client","title":"injection_client  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>injection_client\n</code></pre> <p>Injection client this context is bound to.</p>"},{"location":"reference/abc/#alluka.abc.Context.cache_result","title":"cache_result","text":"<pre><code>cache_result(callback, value)\n</code></pre> <p>Cache the result of a callback within the scope of this context.</p> <p>Whether this does anything or is a noop is implementation detail.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to cache the result of.</p> </li> <li> <code>value</code>               (<code>_T</code>)           \u2013            <p>The value to cache.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Context.call_with_async_di","title":"call_with_async_di  <code>async</code>","text":"<pre><code>call_with_async_di(callback, /, *args, **kwargs)\n</code></pre> <p>Asynchronously call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to call.</p> <p>This may be sync or async.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Context.call_with_di","title":"call_with_di","text":"<pre><code>call_with_di(callback: collections.Callable[..., _CoroT[typing.Any]], /, *args: typing.Any, **kwargs: typing.Any) -&gt; typing.NoReturn\n</code></pre><pre><code>call_with_di(callback: collections.Callable[..., _T], /, *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>call_with_di(callback, /, *args, **kwargs)\n</code></pre> <p>Call a function with the current DI context.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[..., _T]</code>)           \u2013            <p>The callback to call.</p> <p>This must be sync.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the callback.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Context.get_cached_result","title":"get_cached_result","text":"<pre><code>get_cached_result(callback: CallbackSig[_T]) -&gt; _T\n</code></pre><pre><code>get_cached_result(callback: CallbackSig[_T], /, *, default: _DefaultT) -&gt; _T | _DefaultT\n</code></pre> <pre><code>get_cached_result(callback, /, *, default=_NO_VALUE)\n</code></pre> <p>Get the cached result of a callback.</p> <p>This will always raise/default for context implementations with no caching.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to get the cached result of.</p> </li> <li> <code>default</code>               (<code>_DefaultT | _NoValue</code>, default:                   <code>_NO_VALUE</code> )           \u2013            <p>The default value to return if the callback is not cached.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T | _DefaultT</code>           \u2013            <p>The cached result of the callback if found.</p> <p>If the callback's result hasn't been cached or caching isn't implementing then this will return the value of <code>default</code> if it is provided.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no value was found when no default was provided.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.Context.get_type_dependency","title":"get_type_dependency  <code>abstractmethod</code>","text":"<pre><code>get_type_dependency(type_: type[_T]) -&gt; _T\n</code></pre><pre><code>get_type_dependency(type_: type[_T], /, *, default: _DefaultT) -&gt; _T | _DefaultT\n</code></pre> <pre><code>get_type_dependency(type_, /, *, default=...)\n</code></pre> <p>Get the implementation for an injected type.</p> <p>Unlike Client.get_type_dependency, this method may also return context specific implementations of a type.</p> <p>Parameters:</p> <ul> <li> <code>type_</code>               (<code>type[_T]</code>)           \u2013            <p>The associated type.</p> </li> <li> <code>default</code>               (<code>_DefaultT</code>, default:                   <code>...</code> )           \u2013            <p>The default value to return if the type is not implemented.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T | _DefaultT</code>           \u2013            <p>The resolved type if found.</p> <p>If the type isn't implemented then the value of <code>default</code> will be returned if it is provided.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>If no dependency was found when no default was provided.</p> </li> </ul>"},{"location":"reference/abc/#alluka.abc.SelfInjecting","title":"SelfInjecting","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_SyncCallbackT]</code></p> <p>Deprecated interface of a class for marking functions as self-injecting.</p> <p>deprecated</p> <p>This is deprecated as of <code>v0.2.0</code>, use Client.auto_inject.</p>"},{"location":"reference/abc/#alluka.abc.SelfInjecting.callback","title":"callback  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>callback\n</code></pre> <p>The callback this wraps.</p>"},{"location":"reference/abc/#alluka.abc.SelfInjecting.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Call this callback with the provided arguments + injected arguments.</p> <p>Parameters:</p> <ul> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to pass to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The callback's result.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>MissingDependencyError</code>             \u2013            <p>If any of the callback's required type dependencies aren't implemented by the client.</p> </li> <li> <code>SyncOnlyError</code>             \u2013            <p>If the callback or any of its callback dependencies are async.</p> </li> </ul>"},{"location":"reference/local/","title":"alluka.local","text":"<p>Standard functions for using a local scope dependency injection client.</p> <p>The \"scope\" will either be the current thread, an asynchronous runtime or an asynchronous event/task.</p> <p>Note</p> <p>This module's functionality will only work if scope_client or scope_context has been called to set the DI context for the local scope.</p>"},{"location":"reference/local/#alluka.local.initialise","title":"initialise  <code>module-attribute</code>","text":"<pre><code>initialise = initialize\n</code></pre> <p>Alias of initialize.</p>"},{"location":"reference/local/#alluka.local.auto_inject","title":"auto_inject","text":"<pre><code>auto_inject(callback)\n</code></pre> <p>Wrap a function to make calls to it always inject dependencies.</p> <p>Examples:</p> <pre><code>@alluka.local.auto_inject\ndef callback(dep: Injected[Type]) -&gt; None:\n    ...\n\ncallback()  # The requested dependencies will be passed.\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[_P, _T]</code>)           \u2013            <p>The callback to wrap with DI.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The wrapped auto injecting callback.</p> </li> </ul>"},{"location":"reference/local/#alluka.local.auto_inject_async","title":"auto_inject_async","text":"<pre><code>auto_inject_async(callback)\n</code></pre> <p>Wrap an async function to make calls to it always inject dependencies.</p> <p>Examples:</p> <pre><code>@alluka.local.auto_inject_async\nasync def callback(dep: Injected[Type]) -&gt; None:\n    ...\n\nawait callback()  # The requested dependencies will be passed.\n</code></pre> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[_P, _CoroT[_T]]</code>)           \u2013            <p>The callback to wrap with DI.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>The wrapped auto injecting callback.</p> </li> </ul>"},{"location":"reference/local/#alluka.local.call_with_async_di","title":"call_with_async_di  <code>async</code>","text":"<pre><code>call_with_async_di(callback: collections.Callable[..., collections.Coroutine[typing.Any, typing.Any, _T]], *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre><pre><code>call_with_async_di(callback: collections.Callable[..., _T], *args: typing.Any, **kwargs: typing.Any) -&gt; _T\n</code></pre> <pre><code>call_with_async_di(callback, *args, **kwargs)\n</code></pre> <p>Use the local context/client to call a callback with async DI.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>CallbackSig[_T]</code>)           \u2013            <p>The callback to call.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to passthrough to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to passthrough to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the call.</p> </li> </ul>"},{"location":"reference/local/#alluka.local.call_with_di","title":"call_with_di","text":"<pre><code>call_with_di(callback, *args, **kwargs)\n</code></pre> <p>Use the local context/client to call a callback with DI.</p> <p>Parameters:</p> <ul> <li> <code>callback</code>               (<code>Callable[..., _T]</code>)           \u2013            <p>The callback to call.</p> </li> <li> <code>*args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Positional arguments to passthrough to the callback.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to passthrough to the callback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_T</code>           \u2013            <p>The result of the call.</p> </li> </ul>"},{"location":"reference/local/#alluka.local.get","title":"get","text":"<pre><code>get() -&gt; abc.Client\n</code></pre><pre><code>get(*, default: _DefaultT) -&gt; abc.Client | _DefaultT\n</code></pre> <pre><code>get(*, default=_NO_VALUE)\n</code></pre> <p>Deprecated alias of get_client.</p>"},{"location":"reference/local/#alluka.local.get_client","title":"get_client","text":"<pre><code>get_client() -&gt; abc.Client\n</code></pre><pre><code>get_client(*, default: _DefaultT) -&gt; abc.Client | _DefaultT\n</code></pre> <pre><code>get_client(*, default=_NO_VALUE)\n</code></pre> <p>Get the local client for the current scope.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>_DefaultT | _NoValue</code>, default:                   <code>_NO_VALUE</code> )           \u2013            <p>The value to return if no client is set for the current scope.</p> <p>If not provided, a RuntimeError will be raised instead.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Client | _DefaultT</code>           \u2013            <p>The client for the local scope, or the default value if no client is set for the current scope.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If no client is present in the current scope and no default value was provided.</p> </li> </ul>"},{"location":"reference/local/#alluka.local.get_context","title":"get_context","text":"<pre><code>get_context(*, from_client: bool = True) -&gt; abc.Context\n</code></pre><pre><code>get_context(*, default: _DefaultT, from_client: bool = True) -&gt; abc.Context | _DefaultT\n</code></pre> <pre><code>get_context(*, default=_NO_VALUE, from_client=True)\n</code></pre> <p>Get the local context for the current scope.</p> <p>Parameters:</p> <ul> <li> <code>default</code>               (<code>_DefaultT | _NoValue</code>, default:                   <code>_NO_VALUE</code> )           \u2013            <p>The value to return if no context is set for the current scope.</p> <p>If not provided, a RuntimeError will be raised instead.</p> </li> <li> <code>from_client</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to try to make a context from the in-scope Alluka client when no context is set for the current scope.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Context | _DefaultT</code>           \u2013            <p>The context for the local scope, or the default value if no context is set for the current context.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the context is not set for the current context and no default value was provided.</p> </li> </ul>"},{"location":"reference/local/#alluka.local.initialize","title":"initialize","text":"<pre><code>initialize(client=None)\n</code></pre> <p>Link or initialise an injection client for the current scope.</p> <p>This uses contextvars to store the client and therefore will not be inherited by child threads.</p> <p>scope_client and scope_context are recommended over this.</p> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, this will be set as the client for the current scope. If not provided, a new client will be created.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Client</code>           \u2013            <p>The created alluka client.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the local client is already set for the current scope.</p> </li> </ul>"},{"location":"reference/local/#alluka.local.scope_client","title":"scope_client","text":"<pre><code>scope_client(client=None)\n</code></pre> <p>Set the Alluka client for the scope within a context manager.</p> <p>This uses contextvars to store the client and therefore will not be inherited by child threads.</p> <p>Note</p> <p>The client attached to a context set with scope_context will take priority.</p> <p>Examples:</p> <pre><code>def uses_di() -&gt; None:\n    alluka.local.call_with_di(other_callback)\n\nwith alluka.local.scope_client() as client:\n    client.set_type_dependency(Type, value)\n    uses_di()\n\nclient = alluka.Client()\nclient.set_type_dependency(Type, value)\n\nwith alluka.local.scope_client(client):\n    uses_local_di()\n</code></pre> <p>Parameters:</p> <ul> <li> <code>client</code>               (<code>Client | None</code>, default:                   <code>None</code> )           \u2013            <p>The client to set for the context manager's scope.</p> <p>If not provided then a new client will be created.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractContextManager[Client]</code>           \u2013            <p>Context manager which returns the scoped client.</p> </li> </ul>"},{"location":"reference/local/#alluka.local.scope_context","title":"scope_context","text":"<pre><code>scope_context(context=None)\n</code></pre> <p>Set the Alluka context for the scope within a context manager.</p> <p>This uses contextvars to store the context and therefore will not be inherited by child threads.</p> <p>Examples:</p> <pre><code>context = (\n    alluka.OverridingContext(alluka.local.get_context())\n    .set_type_dependency(TypeA, value_a)\n)\n\nwith alluka.local.scope_context(context):\n    uses_local_di()\n</code></pre> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>Context | None</code>, default:                   <code>None</code> )           \u2013            <p>The context to set for the context manager's scope.</p> <p>If not provided then the in-scope Alluka client is used to generate a new context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AbstractContextManager[Context]</code>           \u2013            <p>Context manager which returns the scoped Context.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>When <code>context</code> isn't provided and no Alluka client has been set for the current scope.</p> </li> </ul>"}]}